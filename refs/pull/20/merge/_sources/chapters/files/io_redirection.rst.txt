Redirectări
===========

Interacțiunea cu terminalul a fost până acum în felul următor: am executat o comandă și am urmărit la terminal afișarea rezultatului.
Însă, sunt cazuri în care vrem să păstrăm rezultatul unei comenzi într-un fișier.

Interpretorul de comenzi are opțiunea de a direcționa afișarea rezultatului direct într-un fișier.
Astfel, evităm câțiva pași: copierea conținutului (rezultatul comenzii), crearea unui fișier, deschiderea acestuia, lipirea conținutului.

Rezultatul unei comenzi este format din două fluxuri de informații: informații de ieșire și de eroare.
Avem opțiunea de a redirecta doar ieșirea, doar eroarea sau aumbele fluxuri într-un fișier.

În acest capitol vom învăța cum să facem aceste direcționări (redirectări).

Redirectări simple
------------------
Pentru a direcționa rezultatul unei comenzi, folosim caracterul ``>``, astfel:

.. code-block:: bash

    student@uso:~$ ls -lh
    total 9.0M
    -rw-r--r-- 1 student student 5.0M Aug 19 11:55 USO
    -rw-r--r-- 1 student student 3.0M Aug 19 11:55 RL
    -rw-r--r-- 1 student student 1.0M Aug 19 11:55 EGC
    student@uso:~$ ls -lh > lista_materii
    student@uso:~$ ls
    USO RL EGC lista_materii
    student@uso:~$ cat lista_materii
    -rw-r--r-- 1 student student 5.0M Aug 19 11:55 USO
    -rw-r--r-- 1 student student 3.0M Aug 19 11:55 RL
    -rw-r--r-- 1 student student 1.0M Aug 19 11:55 EGC

Observăm că acțiunea de mai sus a făcut două lucruri: a creat fișierul **lista_materii** și a introdus în conținutul fișierului rezultatul comenzii ``ls -lh``.

.. note::
    Odată direcționat într-un fișier, fluxul de informații nu mai apare la ecran.

.. warning::
    Folosirea caracterului **>** suprascrie conținutul fișierului. Dacă **lista_materii** avea conținut, acesta era înlocuit cu rezultatul comenzii ``ls -lh``.


Sumarizare
^^^^^^^^^^

Dacă la folosirea unei redirectări simple (``>``) și fișierul:

1. Există și e gol, atunci scrie în el;

.. code-block:: bash

    student@uso:~$ ls -l USO
    -rw-r--r-- 1 student student 0 Sep 28 16:34 USO
    student@uso:~$ cat USO
    student@uso:~$ echo "USO RULLZ" > USO
    student@uso:~$ cat USO
    USO RULLZ

2. Există și are conținut, atunci suprascrie/înlocuiește conținutul;

.. code-block:: bash

    student@uso:~$ cat ELTH
    ELTH rullz
    student@uso:~$ echo "USO is the b3st" > ELTH
    student@uso:~$ cat ELTH
    USO is the b3st

3. Nu există, atunci fișierul este creat și se scrie ieșirea comenzii în el.

.. code-block:: bash

    student@uso:~$ ls ELTH
    ls: cannot access ELTH: No such file or directory
    student@uso:~$ echo "ELTH rullz" > ELTH
    student@uso:~$ cat ELTH
    ELTH rullz

Exercițiu - redirectări simple
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Folosiți ``tree`` pentru a afișa ierarhia de fișiere pornind de la **/home/student**;
* Folosiți ``tree`` pentru afișarea aceleiași ierarhii, dar de data asta recționați-o în fișierul **ierarhie_student**;
* Inspectați fișierul pentru a demonstra corectitudinea operației.

Redirectări prin anexare
------------------------
Pentru a direcționa rezultatul comenzii, **fără** a suprascrie fișierul, folosim caracterele ``>>``, astfel:

.. code-block:: bash

    student@uso:~$ ls >> lista_materii
    student@uso:~$ ls
    USO RL EGC lista_materii
    student@uso:~$ cat lista_materii
    -rw-r--r-- 1 student student 5.0M Aug 19 11:55 USO
    -rw-r--r-- 1 student student 3.0M Aug 19 11:55 RL
    -rw-r--r-- 1 student student 1.0M Aug 19 11:55 EGC
    USO RL EGC lista_materii


Observăm că la sfârșitul fișierului creat anterior, s-a adăugat o linie cu noul rezultat al comenzii ``ls``.

Sumarizare
^^^^^^^^^^

Dacă la folosirea unei redirectări prin anexare (``>>``) și fișierul:

1. Există și este gol, atunci scrie în el;

.. code-block:: bash

    student@uso:~$ ls -l materii
    -rw-r--r-- 1 student student 0 Sep 28 17:00 materii
    student@uso:~$ cat materii
    student@uso:~$ echo "USO RL ELTH" >> materii
    student@uso:~$ cat materii
    USO RL ELTH

2. Există și are conținut, atunci scrie la sfârșitul fișierului;

.. code-block:: bash

    student@uso:~$ cat materii
    USO RL ELTH
    student@uso:~$ echo "EGC SO2" >> materii
    student@uso:~$ cat materii
    USO RL ELTH
    EGC SO2

3. Nu există, atunci fișierul este creat și se scrie ieșirea comenzii în el.

.. code-block:: bash

    student@uso:~$ rm materii
    student@uso:~$ ls -l materii
    ls: cannot access materii: No such file or directory
    student@uso:~$ echo "USO RL EGC" >> materii
    student@uso:~$ cat materii
    USO RL EGC


Exercițiu - redirectări prin anexare
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Folosiți ``tree`` pentru a afișa ierarhia de fișiere pornind de la **/tmp**;
* Folosiți ``tree`` pentru a afișa aceeași ierarhie, dar de data asta direcționați-o prin anexare la fișierul **ierarhie_student** creat anterior;
* Inspectați fișierul pentru a demonstra corectitudinea operației.

Exercițiu - redirectări prin anexare
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* Folosiți ``tree`` pentru a afișa ierarhia de fișiere pornind de la **/usr**;
* Repetați comanda anterioara, dar de data asta direcționați-o **fără** anexare la fișierul **ierarhie_student** folosit anterior;
* Inspectați fișierul pentru a demonstra corectitudinea operației. Mai exista conținutul inițial al fișierului?


Redirectări de eroare
---------------------

Atunci când direcționăm ieșirea unei comenzi folosind ``>`` sau ``>>``, ne referim **doar** la ieșirea standard (nu și la erori).

Putem folosi caracterele ``2>`` pentru a direcționa ieșirea de eroare către un fișier.

.. code-block:: bash

    student@uso:~$ ls
    USO RL EGC lista_materii
    student@uso:~$ cat lista_materie
    cat: dsa: No such file or directory

Observăm că la exemplul anterior, am vrut să afișăm conținutul fișierului **lista_materie**, fișier ce nu există.
Am primit informația *No such file or directory*, dar aceasta este afișată **sub formă de eroare**.

.. code-block:: bash

    student@uso:~$ cat SO2 > materii
    cat: SO2: No such file or directory


Observăm că dacă folosim redirectarea simplă ``>``, eroarea tot este afișată.

.. note::
    Chiar dacă comanda de interes eșuează, redirectarea este făcută. În cazul de mai sus, fișierul **materii** este creat.

.. code-block:: bash

    student@uso:~$ cat SO2 2> materii
    student@uso:~$ cat materii
    cat: SO2: No such file or directory

Observăm că nu am primit eroare la prima comandă unde am încercat să afișăm conținutul unui fișier inexistent.
Informațiile de eroare au fost redirectate în fișier.


.. note::
    Redirectările de eroare și ieșire pot fi folosite simultan folosind caracterele specifice ``>`` pentru ieșire și ``2>`` pentru eroare.
    Putem folosi sintaxa ``comanda > fișier_ieșire 2> fișier_erori`` pentru a face acest lucru..

.. code-block:: bash

    student@uso:~$ cat ELTH USO SO2
    USO is the b3st
    USO RULLZ
    cat: SO2: No such file or directory

În exemplul de mai sus încercăm să afișăm conținutul fișierelor ELTH, USO și SO2, dar cu fișierul SO2 neexistent.
Primele două linii fac parte din fluxul de ieșire: conținutul fișierelor ELTH și USO.
Ultimul rând face parte din fluxul de eroare și ne informează că fișierul SO2 nu există.
În continuare vom face o separare a fluxurilor: direcționăm ieșirea într-un fișier și erorile în alt fișier.

.. code-block:: bash

    student@uso:~$ cat ELTH USO SO2 > continut_materii 2> erori_comenzi
    student@uso:~$ cat continut_materii
    USO is the b3st
    USO RULLZ
    student@uso:~$ cat erori_comenzi
    cat: SO2: No such file or directory

Observăm cum după executarea primei comenzi, la ecran nu mai apare nimic; atât ieșirea standard cât și erorile au fost direcționate în fișiere.
În continuare am verificat conținutul acestor fișiere pentru a demonstra corectitudinea operației.
