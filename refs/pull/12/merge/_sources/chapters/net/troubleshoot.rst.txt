Verificarea conectivităţii la reţea
===================================

Pentru identificarea și repararea problemelor de conectivitate la rețea este
necesar să parcurgem toate nivelele de rețea prin care trec datele pentru a fi
trimise pe rețea. La fiecare pas vom vedea cum verificăm funcționalitatea
nivelului de rețea și cum putem să îl configurăm sumar.

1) Interacţiunea cu nivelul fizic
---------------------------------

Primul nivel cu care noi interacționăm este nivelul fizic. Nivelul fizic este
reprezentat de cablul UTP <insert poză>, sau de undele radio ale unei rețele
wireless. Acestea sunt mediul prin care informația este transferată.

O altă componentă a nivelului fizic este placa de rețea a sistemului. Aceasta
va trimite mesaje prin mediu de transmisie, fie acesta cablu de cupru, fibră sau
unde radio.

La nivel fizic, putem verifica conexiunea și funcționalitatea unei plăci de
rețea uitându-ne la becurile care reprezintă conexiunea la mediul fizic.
Observăm în GIF-ul <TODO> cum arată becurile unei plăci de rețea funcționale.
Dacă acestea nu sunt aprinse, atunci nu vom avea conectivitate la rețea.

a. Investigarea nivelului fizic al rețelei
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NOTĂ

În cadrul Linux numim interfață de rețea o placă de rețea.

La nivelul sistemului de operare putem verifica dacă o placă de rețea este
activă folosind comanda următoare:


.. code-block::

    student@uso:~$ ip link show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff


Starea fiecărei interfețe de rețea este reprezentată pe câte o linie împreună cu
parametrii săi de rulate.

Observăm că interfața de rețea cu numele wlo1 este pornită, deoarece linia care
conține parametrii săi conține și starea UP. În același timp observăm că
interfața de rețea eno2 nu este activă deoarece pe linia sa observăm parametrul
DOWN.

Pentru a porni interfața eno2 vom folosi următoarea comandă:

.. code-block::

    student@uso:~$ ip link set up dev eno2

Mereu după ce rulăm o comandă trebuie să verificăm că s-a efectuat comanda cu
succes folosind o comandă de verificare. În cazul de față vom folosi tot
comanda `ip link show`:

.. code-block::

    student@uso:~$ ip link show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff

b. Configurarea reţelei în mediul grafic
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le vom arăta cum să se conecteze la o rețea folosind interfaţa vizuală a unui
Desktop Environment, probabil GNOME

2) Configurarea nivelului Internet
----------------------------------

Pentru conectarea la Internet între stații este nevoie să identificăm stațiile.
Se pune problema identificării adresei unui sistem deoarece ne dorim să identificăm
când trimitem un mesaj cui să trimitem mesajul și pe unde să trimitem mesajul.

Pentru identificarea stațiilor folosim o adresă numită adresa IP. Fiecare
interfață de rețea are nevoie de o adresă IP să fie configurată pentru a
trimite mesaje în Internet prin ea.

Pentru a vedea adresele IP configurate pe interfețele de rețea folosim
următoarea comandă:

.. code-block::

    student@uso:~$ ip address show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
        inet 127.0.0.1/8 scope host lo
           valid_lft forever preferred_lft forever
        inet6 ::1/128 scope host 
           valid_lft forever preferred_lft forever
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff
        inet 192.168.1.103/24 brd 192.168.1.255 scope global dynamic noprefixroute wlo1
           valid_lft 6478sec preferred_lft 6478sec
        inet6 fe80::3849:c687:463f:5508/64 scope link noprefixroute 
           valid_lft forever preferred_lft forever

Adresele IP ale interfețelor sunt scrise pe liniile care conțin `inet`.
Observăm că există două tipuri de adrese IP, în funcție de parametrul `inet`:

* Adrese IPv4 care sunt de forma "A.B.C.D", unde A, B, C și D sunt numere cu
  valori între 1 si 255
* Adrese IPv6, care sunt de forma "A:B:C:D:E:F:G:H", unde A-H sunt numere în
  format hexazecimal care pot lua valori de la "0x0000" la "0xFFFF"

a. Configurarea unei adrese IP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RECAPITULARE:

Porniți interfața eno2.

Există două metode pentru configurarea unei adrese IP pe o interfață:

* configurare statică, implică să cunoaștem din ce rețea face parte interfața
  pe care vrem să o configurăm

* configurare dinamică, care nu presupune cunoașterea informațiilor despre
  rețea, deoarece acestea vor fi primite automat de pe rețea

Vom insista pe configurarea dinamică, deoarece majoritatea timpului nu avem cum
să aflam informațiile despre rețea înainte de a configura interfața de rețea.
De exemplu, atunci când ne conectăm la o rețea wireless, nu știm care sunt
adresele IP disponibile în acea rețea, așă că folosim protocolul DHCP pentru a
cere o adresă IP de la un server care cunoaște configurarea rețelei.


Pentru a obține a seta dinamic o adresă IP în mod dinamic pe o interfață
folosim comanda `dhclient` în felul următor:

.. code-block::

    student@uso:~$ dhclient eno2

Mai sus am rulat comanda pentru a obține o adresă IP pentru interfața eno2.

TASK DE RECAPITULARE:

Afișați adresele IP de pe toate interfețele.

Observați că am obținut o adresă IP pe interfața eno2.

Pentru șterge o adresă IP de pe o interfața folosim comanda `ip address flush` în felul următor:

.. code-block::

    student@uso:~$ ip address flush eno2
    student@uso:~$ ip address show
    <TODO>

TASK DE RECAPITULARE:

Configurați adresa IP pe interfața eno3


b. Verificarea conectivității la o altă stație
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Pentru a verifica conexiunea dintre două stații folosim comanda `ping`. Această
comandă trimite mesaje către o stație și așteaptă un răspuns de la ea.

Atunci când testăm conexiunea la internet, vrem să verificăm câteva aspecte,
odată ce am obținut o adresă IP de la serverul DHCP:

* verificăm dacă putem să ne conectăm la alte calculatoare din aceeași rețea

* verificăm dacă putem să comunicăm cu stații din afara rețelei

Comanda `ping` se folosește în felul următor:

.. code-block::

    student@uso:~$ ping 127.0.0.1
    <TODO>

Atunci când nu pot fi trimise mesaje către stația identificată prin adresa IP
mesajul de eroare va arăta în felul următor:

.. code-block::

    student@uso:~$ ping <TODO>
    <TODO>

Pentru verificarea conectivității în interiorul rețelei trebuie să verificăm că
putem să trimitem mesaje folosind ping unui calculator din rețea.

O țintă bună de testare pentru trimiterea mesajelor în rețea este default
gateway-ul. Un default gateway este un dispozitiv de rețea care se ocupă de
interconectarea rețelelor și care primește mesaje de la toate stațiile din
rețea pentru a le trimite în Internet.

Default gateway-ul este configurat static sau dinamic, cum este configurată și adresa IP a unei interfețe.

Pentru a identifica gateway-ul default folosim comanda `ip route show` în felul următor:

.. code-block::

    student@uso:~$ ip route show default
    <TODO>

Observăm că adresa IP a stației gateway este <TODO>.

RECAPITULARE:

Aflați adresa de rețea de pe interfața <TODO>.

OBSERVAȚIE:

După cum putem să observăm, adresa IP a gateway-ului și adresa IP a interfeței
<TODO> sunt foarte similare. Asta se întâmplă deoarece stațiile se află în
aceeași rețea.

EXERCIȚIU:

Verificați conexiunea cu gateway-ul default folosind comanda `ping`.

Pentru verificarea conexiunii la Internet este bine să verificăm cu o adresă
consacrată, care avem încredere că nu va avea probleme tehnice. Un astfel de
exemplu este server-ul de DNS oferit de Google, care se află la adresa IP 8.8.8.8.

EXERCIȚIU:

Verificați conexiunea la server-ul de DNS oferit de Google folosind comanda `ping`.

c. Investigarea serviciului DNS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

După cum ați observat, până acum am lucrat numai cu adrese IP, dar noi lucrăm
în viața de zi cu zi cu numele site-urilor, deoarece ne este mai ușor să
reținem nume decât adrese IP.

Ne dorim să avem un serviciu DNS funcțional în permanență pe sistemul pe care lucrăm.

În mod implicit serviciul DNS este configurat prin DHCP.

.. code-block::

    student@uso:~$ nmcli dev show | grep DNS
    <TODO>

RECAPITULARE:

Afișați adresa IP a default gateway-ului.

OBSERVAȚIE:

Observați că adresa gateway-ului este aceeași cu adresa DNS-ului. De obicei
server-ul gateway este configurat ca server DNS, iar acesta va trimite cererile
mai departe către un alt server DNS.

Pentru a verifica funcționalitatea DNS-ului, putem să facem o cerere DNS folosind comanda `dig` în felul următor.

.. code-block::

    student@uso:~$ dig google.com
    <TODO>

Cererile DNS nu trebuie să fie făcute direct de noi atunci când încercăm să accesăm o resursă din internet folosind un nume, deoarece aplicațiile fac cereri în mod implicit.

EXEMPLU:

.. code-block::

    student@uso:~$ ping google.com
    <TODO>

Observați că aplicația ping a aflat de una singură care este adresa IP asociată
numelui google.com și a făcut cererea în fundal.

În caz că vrem să schimbăm temporar DNS-ul pe care îl folosim trebuie să
modificăm fișierul /etc/resolv.conf. Acest fișier specifică DNS-ul care va fi
folosit pentru cereri pe linia care conține cuvântul nameserver, după cum
puteți vedea mai jos.

.. code-block::

    student@uso:~$ cat /etc/resolv.conf
    <TODO>

Dacă schimbăm adresa DNS-ului cu altă adresă, cum ar fi cea a DNS-ului oferit
de Google, putem să vedem o schimbare în răspunsurile de la serverul DNS.


.. code-block::

    student@uso:~$ dig google.com
    <modificăm /etc/resolv.conf>
    student@uso:~$ cat /etc/resolv.conf
    <TODO>
    student@uso:~$ dig google.com
    <TODO>

ATENȚIE:

Acestea sunt modificări temporare folosite pentru depanarea problemelor cu
serviciul DNS.

EXERCIȚIU:

Realizați modificările necesare astfel încât cererile de tip DNS să fie trimise
către serverul de DNS oferit de CloudFlare de la adresa 1.1.1.1.

3) Configurarea nivelului Transport
-----------------------------------

Atunci când folosim internetul ce facem de fapt este că ne conectăm la
aplicații care rulează și noi pornim la rândul nostru aplicații care așteaptă
conexiuni din exterior.

Pentru a distinge aplicațiile și destinația mesajelor, folosim conceptul de
porturi. Astfel, fiecare aplicație deschide un port pentru a comunica cu exteriorul.

Există două tipuri de port-uri care pot fi deschis, în funcție de protocolul folosit:

* porturi TCP, folosite de aplicații care depind de trimiterea corectă și în
  ordine a informației, cum ar fi servere web;

* porturi UDP, folosite de aplicații care trebuie să trimită informație repede
  și care sunt rezistente la greșeli de trimitere ale pachetelor, cum ar fi
  aplicații de video streaming

a. Conectivitatea între aplicații de rețea folosind porturi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Pentru afișarea porturilor deschide, pe care comunica o aplicație, folosim comanda `netstat`:

.. code-block::

    student@uso:~$ netstat -tlpn
    <TODO>

OBSERVAȚIE:

Pentru comanda de mai sus folosim următoarele opțiuni pentru filtrarea afișării:

* `-t` afișează doar porturile TCP deschise

* `-l` afișează doar porturile deschise care ascultă mesaje, nu și cele deschide pentru trimiterea mesajelor

* `-p` afișează programul care a deschis portul

* `-n` afișează IP-ul pe care se ascultă după conexiuni

EXERCIȚIU:

Afișați porturile UDP deschise pe stația pe care lucrați.

După cum observăm, există un server HTTP care rulează pe mașină și ascultă pe portul 80.

b. Conectarea TCP la o aplicație
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vrem să observăm cum răspunde această aplicație la mesaje. De regula un server HTTP răspunde printr-un mesaj în format HTML.

Pentru a trimite mesaje, indiferent de tipul aplicației care primește mesajul folosim comanda `nc` în felul următor

.. code-block::

    student@uso:~$ nc 127.0.0.1 80
    lala
    HTTP/1.1 400 Bad Request
    Server: nginx/1.18.0
    Date: Tue, 01 Sep 2020 21:46:35 GMT
    Content-Type: text/html
    Content-Length: 157
    Connection: close
    
    <html>
    <head><title>400 Bad Request</title></head>
    <body>
    <center><h1>400 Bad Request</h1></center>
    <hr><center>nginx/1.18.0</center>
    </body>
    </html>

OBSERVAȚI:

Mesajul primit este un răspuns de tipul "Bad Request", deoarece am trimis un
mesaj care nu este în formatul așteptat de serverul HTTP.

EXERCIȚIU:

Trimiteți un mesaj către programul care ascultă pe portul 8080 pe mașina locală
(cu IP-ul 127.0.0.1).
