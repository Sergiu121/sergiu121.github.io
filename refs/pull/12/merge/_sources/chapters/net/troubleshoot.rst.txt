Verificarea conectivităţii la reţea
===================================

Pentru identificarea și repararea problemelor de conectivitate la rețea este
necesar să parcurgem toate nivelele de rețea prin care trec datele pentru a fi
trimise pe rețea. La fiecare pas vom vedea cum verificăm funcționalitatea
nivelului de rețea și cum putem să îl configurăm sumar.

1) Interacţiunea cu nivelul fizic
---------------------------------

Primul nivel cu care noi interacționăm este nivelul fizic. Nivelul fizic este
reprezentat de cablul UTP <insert poză>, sau de undele radio ale unei rețele
wireless. Acestea sunt mediul prin care informația este transferată.

O altă componentă a nivelului fizic este placa de rețea a sistemului. Aceasta
va trimite mesaje prin mediu de transmisie, fie acesta cablu de cupru, fibră sau
unde radio.

La nivel fizic, putem verifica conexiunea și funcționalitatea unei plăci de
rețea uitându-ne la becurile care reprezintă conexiunea la mediul fizic.
Observăm în GIF-ul <TODO> cum arată becurile unei plăci de rețea funcționale.
Dacă acestea nu sunt aprinse, atunci nu vom avea conectivitate la rețea.

a. Investigarea nivelului fizic al rețelei
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NOTĂ

În cadrul Linux numim interfață de rețea o placă de rețea.

La nivelul sistemului de operare putem verifica dacă o placă de rețea este
activă folosind comanda următoare:


.. code-block::
    student@uso:~$ ip link show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff


Starea fiecărei interfețe de rețea este reprezentată pe câte o linie împreună cu
parametrii săi de rulate.

Observăm că interfața de rețea cu numele wlo1 este pornită, deoarece linia care
conține parametrii săi conține și starea UP. În același timp observăm că
interfața de rețea eno2 nu este activă deoarece pe linia sa observăm parametrul
DOWN.

Pentru a porni interfața eno2 vom folosi următoarea comandă:

.. code-block::
    student@uso:~$ ip link set up dev eno2

Mereu după ce rulăm o comandă trebuie să verificăm că s-a efectuat comanda cu
succes folosind o comandă de verificare. În cazul de față vom folosi tot
comanda `ip link show`:

.. code-block::
    student@uso:~$ ip link show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DORMANT group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff

b. Configurarea reţelei în mediul grafic
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le vom arăta cum să se conecteze la o rețea folosind interfaţa vizuală a unui
Desktop Environment, probabil GNOME

2) Configurarea nivelului Internet
----------------------------------

Pentru conectarea la Internet între stații este nevoie să identificăm stațiile.
Se pune problema identificării adresei unui sistem deoarece ne dorim să identificăm
când trimitem un mesaj cui să trimitem mesajul și pe unde să trimitem mesajul.

Pentru identificarea stațiilor folosim o adresă numită adresa IP. Fiecare
interfață de rețea are nevoie de o adresă IP să fie configurată pentru a
trimite mesaje în Internet prin ea.

Pentru a vedea adresele IP configurate pe interfețele de rețea folosim
următoarea comandă:

.. code-block::
    student@uso:~$ ip address show
    1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
        link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
        inet 127.0.0.1/8 scope host lo
           valid_lft forever preferred_lft forever
        inet6 ::1/128 scope host 
           valid_lft forever preferred_lft forever
    2: eno2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
        link/ether c8:f7:50:78:a1:a7 brd ff:ff:ff:ff:ff:ff
    3: wlo1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
        link/ether a0:51:0b:68:3d:55 brd ff:ff:ff:ff:ff:ff
        inet 192.168.1.103/24 brd 192.168.1.255 scope global dynamic noprefixroute wlo1
           valid_lft 6478sec preferred_lft 6478sec
        inet6 fe80::3849:c687:463f:5508/64 scope link noprefixroute 
           valid_lft forever preferred_lft forever

Adresele IP ale interfețelor sunt scrise pe liniile care conțin `inet`.
Observăm că există două tipuri de adrese IP, în funcție de parametrul `inet`:

a. Configurarea unei adrese IP
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le dăm o maşină care are interfaţa pornită, dar le arătăm ca nu are IP pe
interfaţă. Le arătăm comanda `dhclient <interfaţă>` pentru a obţine adresa IP şi
le arătăm că pot să dea ping la un calculator, dar nu se pot da ping la anumite
adrese IP.

b. Inspectarea rutelor din sistem
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le explicăm ce înseamnă o reţea de calculatoare şi de ce nu le merge să iasă din
reţeaua lor, că nu este setat un default gateway. Îi punem să dea `traceroute`
înainte şi după ce adaugă o rută de mână (sau putem să îi punem sa dea iar
dhclient, dar pe o altă maşină pe care este configurat dhclient să dea gateway)
şi îi punem să dea a doua oară traceroute, ca să vadă că iese din reţea acum.

c. Configurarea gateway-ului
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le explicăm ce înseamnă o reţea de calculatoare şi de ce nu le merge să iasă din
reţeaua lor, că nu este setat un default gateway. Îi punem să dea `traceroute`
înainte şi după ce adaugă o rută de mână (sau putem să îi punem sa dea iar
dhclient, dar pe o altă maşină pe care este configurat dhclient să dea gateway)
şi îi punem să dea a doua oară traceroute, ca să vadă că iese din reţea acum;

d. Verificarea conectivității la o altă stație
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le vom arăta cum să folosească comanda `ping` pentru a verifica conexiunea cu
diverse stații.

Pentru a face troubleshooting facil este necesar să porniţi de la primul nivel
al stivei de reţea şi să verificaţi folosind comenzile de verificare de mai sus
(`ip address show`, `ip route show`, `traceroute`, `ping <adresă IP>`, `ping
<hostname>`) pentru a verifica funcţionalitatea fiecărui nivel.

d. Investigarea serviciului DNS
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le vom arăta cu o imagine cum funcţionează DNS-ul şi le vom arăta că poate fi
configurat temporar din /etc/resolv.conf, pentru a testa alte servere de DNS.

Le vom arăta cum se foloseşte comanda `dig`, pentru a verifica răspunsurile de
la diverse DNS-uri, gen Google şi CloudFlare.

3) Configurarea nivelului Transport
-----------------------------------

a. Conectivitatea între aplicații de rețea folosind porturi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Le arătăm că fiecare aplicaţie care vrea să răspundă la cereri se foloseşte de
porturi. Pentru asta vom folosi `netcat` pentru a deschide un port, iar apoi
vom folosi `netstat` pentru a vedea ca a fost deschis portul.

b. Pornirea unei aplicaţii care folosește porturi
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Studenţii se vor conecta la portul deschis folosind `netcat`, şi vor scrie la
tastatura ceva pentru a apărea pe server.

c. Conectarea TCP la o aplicație
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Vom pune studenții sa se conecteze la portul 80 al unui site (cum ar fi
elf.cs.pub.ro) și să vadă ce apare la terminal. Astfel, le vom explica ca
server-ele deschid un port la care se conectează serviciile client.
