Instalarea aplicațiilor (serviciilor) folosind Docker
=====================================================

Scopul acestui capitol este să îi introducem pe studenți în instalarea, folosirea containerelor și în instalarea serviciilor folosind containerele.

Instalarea serviciilor nu este o operație ușoară.
Acestea depind de aplicații și biblioteci care uneori nu sunt disponibile, sau nu există versiunile necesare pentru distribuția noastră.
O altă problemă vine de la faptul că serviciile nu sunt de tipul "plug-and-play", adică nu oferă o configurație simplă care să permită rularea serviciului imediat după instalarea aplicației.

Docker vine ca o soluție pentru această problemă, deoarece acesta ne oferă servicii pre-împachetate cu dependențele pe care le are serviciul respectiv și cu configurările necesare pentru rularea serviciului.
Un alt avantaj al folosirii Docker este că mediul oferit de Docker este unul izolat și efemer, adică o aplicație care rulează în Docker nu are acces în mod obișnuit la restul sistemului, iar orice modificare asupra sistemului de fișiere din Docker nu se va reflecta asupra sistemului.

Containerele sunt un mediu în care putem rula aplicații izolate de sistemul gazdă.

În sistemele de operare bazate pe Linux, containerele sunt rulate ca o aplicație care are acces la resursele stației gazdă, dar care poate interacționa cu procesele din în afara mediului izolat.

Avantajul utilizării unui container pentru rularea aplicațiilor este că poate fi pornit și oprit cu ușurință si modificate.
Astfel, putem instala aplicații într-un container, le putem configura și rula fără a afecta celelalte componente ale sistemului

Folosirea Docker
----------------

Un caz de utilizare în care rulăm containere este atunci când vrem să setăm un server care depinde de
versiuni fixe, vechi ale anumitor biblioteci. Nu vrem să rulăm acel server pe sistemul nostru
fizic, deoarece pot apărea conflicte cu alte aplicații. Containerizing serverul, putem avea un
versiunea bibliotecii instalată pe mașina fizică și o altă versiune instalată pe
container fără conflict între ele.

Containere versus mașini virtuale
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Atât containerele cât și mașinile virtuale ne permit să rulăm aplicații într-un mediu izolat.
Totuși, există diferențe fundamentale între cele două mechanisme.
Conform schemei de mai jos, un container rulează direct peste nucleul sistemului de operare gazdă.
În schimb, o mașină virtuală execută propriul nucleu care apoi rulează aplicațiile.
Acest nivel în plus de operații executate adaugă overhead rulării aplicațiilor dorite, iar overheadul încetinește viteza de execuție.

Un alt avantaj al containerelor este abilitatea de a le construi și ambala iterativ.
Practic, noi putem să descărcăm cu ușurință un container de pe un repository public, să îl modificăm și să îl încărcăm într-un repository public fără să încărcăm întreaga imagine.
Putem face asta, deoarece modificările asupra unui container sunt făcute iterativ, salvând diferențele dintre imaginea inițială și versiunea modificată.

Există și cazuri în care vrem să rulăm aplicațiile în interioriul unei mașini virtuale.
De exemplu, dacă vrem să rulăm o aplicație compilată pentru un alt sistem de operare în afară de Linux, nu vom putea face asta, deoarece containerele pot executa aplicații care sunt compilate pentru sistemul de operare gazdă.
Mașinile virtuale pot să ruleze și sisteme de operare diferite de sistemul de operare gazdă.

Gestionarea containerelor
^^^^^^^^^^^^^^^^^^^^^^^^^

În această sub-subsecțiune vom prezenta cum să descarce și cum să pornească un container care oferă o pagină web simplă, ca apoi să oprească containerul.

Pentru a porni o aplicație în interiorul unui container Docker folosim următoarea comandă:

```
student@uso:~$ docker run -it ubuntu:18.04 bash
Unable to find image 'ubuntu:18.04' locally
18.04: Pulling from library/ubuntu
92dc2a97ff99: Pull complete
be13a9d27eb8: Pull complete
c8299583700a: Pull complete
Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
Status: Downloaded newer image for ubuntu:18.04
root@86c268b30cd6:/#
```

Comanda `docker` a fost rulată folosind următorii parametrii:
* `run`, pornește un container;
* `-i`, pornește un container "interactiv", care acceptă input de la tastatură;
* `-t`, asociază un termina virtual comenzii rulate;
* `ubuntu:18.04` este numele imaginii pe care vrem să o folosim. [Dockerhub](https://hub.docker.com/) este un repository public de imagini de unde putem descărca imagini deja construite;
* `bash`, comanda pe care vrem să o rulăm în cadrul containerului.

Putem rula și o comandă neinteractivă în container în felul următor:

```
student@uso:~$ docker run ubuntu:18.04 ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 12:01 ?        00:00:00 ps -ef
```

* instalarea facilă a unui serviciu
* configurarea unui mediu de dezvoltare izolat
* replicarea unui serviciu din producție local
* configurarea unui mediu replicabil pentru testare

:::note
Comanda `ps -ef` afișează toate procesele active din sistem. Observăm că în rezultatul de mai sus apare o singură comandă, deoarece rulăm într-un mediu izolat.
:::

Cu toate acestea, nu dorim să rulăm întotdeauna containere în prim plan. Dacă vrem să rulăm un script care nu poate fi rulat în mediul gazdă, iar acest script va rula mult timp, preferăm să rulăm comanda în fundal.

Pentru a rula un script în fundal în cadrul unui container Docker vom folosi opțiunea `-d` a comenzii `docker run` în felul următor:
```
student@lab-docker:~$ sudo docker run -d ubuntu:18.04 sleep 10000
a63ee06826a33c0dfab825a0cb2032eee2459e0721517777ee019f59e69ebc02
student@lab-docker:~$ sudo docker ps
CONTAINER ID   IMAGE          COMMAND         CREATED         STATUS         PORTS     NAMES
a63ee06826a3   ubuntu:18.04   "sleep 10000"   7 seconds ago   Up 5 seconds             wonderful_lewin
student@lab-docker:~$ sudo docker exec -it a63ee06826a3 /bin/bash
root@a63ee06826a3:/# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 02:19 ?        00:00:00 sleep 10000
root           7       0  2 02:19 pts/0    00:00:00 /bin/bash
root          19       7  0 02:20 pts/0    00:00:00 ps -ef
root@a63ee06826a3:/# exit
```

Putem vedea că containerul pornit de noi încă rulează rulând comanda `docker ps`.
Coloane relevante sunt:
* `CONTAINER ID`
* `NAMES`

Pentru a ne conecta la un container care rulează în fundal, ne folosim de comanda `docker exec` împreună cu ID-ul containerului sau numele selectat folosind comanda `docker ps`:

```
student@lab-docker:~$ sudo docker ps
CONTAINER ID   IMAGE          COMMAND         CREATED         STATUS         PORTS     NAMES
a63ee06826a3   ubuntu:18.04   "sleep 10000"   7 seconds ago   Up 5 seconds             wonderful_lewin
student@lab-docker:~$ sudo docker exec -it a63ee06826a3 /bin/bash
root@a63ee06826a3:/# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 02:19 ?        00:00:00 sleep 10000
root           7       0  2 02:19 pts/0    00:00:00 /bin/bash
root          19       7  0 02:20 pts/0    00:00:00 ps -ef
root@a63ee06826a3:/# exit
```

Pentru a opri un container care rulează în fundal, utilizați comanda „docker stop” împreună cu ID-ul sau numele containerului, în felul următor:
```
student@lab-docker:~$ sudo docker stop a63ee06826a3
a63ee06826a3
student@lab-docker:~$ sudo docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
student@lab-docker:~$
```


## Exerciții: Gestionarea containerelor

* Porniți un nou container în fundal folosind imaginea de bază `centos:7`.
* Conectați-vă la containerul tocmai pornit și instalați aplicația `bind-utils` folosind comanda `yum install bind-utils`. Pentru a verifica faptu că ați instalat aplicația corect, verificați-vă rulând comanda `nslookup google.com`.
* Deconectați-vă de la container și opriți-l.

Instalarea serviciilor folosind Docker
--------------------------------------

Cum am prezentat mai devreme, un avantaj al folosirii containerelor este faptul că putem să descărcăm containere care pot rula servicii.
Aceste servicii nu vor mai fi lansate și gestionate de aplicația systemd care rulează pe stația de lucru, deoarece acestea vor rula în cadrul unui container care va gestiona rularea serviciului.
Noi trebuie doar să ne asigurăm ca rulăm containerul folosind opțiunile potrivite.

Identificarea containerelor pe Dockerhub
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Precum aplicațiile obișnuite, și containerele Docker pot fi descărcate dintr-un repository central.
Repository-ul central pentru containere pe care îl vom folosi este DockerHub <TODO REF>. Acesta nu este singurul repository de containere pe care putem să îl folosim, dar este cel mai vast.
Noi vom folosi site-ul Dockerhub pentru a căuta containere împreună cu instrucțiuni de folosire ale acestora.

Instalarea unui server de minecraft folosind containere
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Își vor instala un server de Minecraft pe PC, pe care îl vor testa folosind TLauncher (nu știu cât de legal e asta, TBD).

Instalarea Grafana folosind containere
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Își vor instala un server de grafana și baza de date pentru acesta.

Extra: Instalarea containerelor personalizate
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Studenții vor descărca un Dockerfile și vor face build acestuia în loc să descarce direct containerul despre net.

Le vom arăta cum să modifice Dockerfile-ul ca să instaleze diverse aplicații.
